time complexity:  একটি প্রোগ্রাম বা অ্যালগরিদম এর কমপ্লেক্সিটি সংখ্যা বা চলতে কত সময় লাগে । 

1.Arithmetic Operation:O(1)
2.Relational Operation:O(1)
3.Assignment Operation:O(1)

==========================

ইনপুট এর সংখ এর উপরে যদি অপারেশন এর পরিমাপ নির্ভর না করে তাহলে O(1)

বিগ ও নোটেশনে, **O(1)** মানে হলো **কনস্ট্যান্ট টাইম কমপ্লেক্সিটি**। অর্থাৎ, অপারেশনটি সম্পাদনে যতই ইনপুটের সাইজ বাড়ুক না কেন, সময়ের পরিমাণ অপরিবর্তিত থাকে। নিচের ক্ষেত্রগুলোতে এই কমপ্লেক্সিটি প্রযোজ্য:

### 1. **অ্যারিথমেটিক অপারেশন (+, -, *, /, %)**
   - উদাহরণ: `a + b`, `x * y`, `n % 2`
   - **কারণ:** প্রসেসর এই অপারেশনগুলোকে **একটি কনস্ট্যান্ট টাইমে** সম্পন্ন করে (হ্যার্ডওয়্যার লেভেলে ফিক্সড ক্লক সাইকেল)।

### 2. **রিলেশনাল অপারেশন (>, <, ==, !=)**
   - উদাহরণ: `if (a > b)`, `while (x != 0)`
   - **কারণ:** দুটি ভ্যালু কম্পেয়ার করার সময় প্রসেসরের জন্য এটি একটি সিম্পল অপারেশন (ফিক্সড টাইম)।

### 3. **অ্যাসাইনমেন্ট অপারেশন (=, +=, -=)**
   - উদাহরণ: `a = 10`, `x += 5`
   - **কারণ:** মেমোরিতে ভ্যালু সেট করা বা আপডেট করা একটি কনস্ট্যান্ট টাইম অপারেশন।

---

### কেন O(1)?
যদি **ইনপুটের সাইজ (n)** বাড়লেও অপারেশনের সংখ্যা **অপরিবর্তিত থাকে**, তাহলে সেটি **O(1)**।  
**উদাহরণ:**  
```python
def print_first_element(arr):
    print(arr[0])  # অ্যারের প্রথম এলিমেন্ট অ্যাক্সেস = O(1)
```
এখানে অ্যারের সাইজ যতই হোক না কেন, শুধু প্রথম এলিমেন্ট অ্যাক্সেস করা হচ্ছে। তাই টাইম কমপ্লেক্সিটি **O(1)**।

---

### O(1) vs O(n)
| কেস | উদাহরণ | কমপ্লেক্সিটি |
|------|---------|-------------|
| **O(1)** | `x = 5 + 3` | ইনপুটের উপর নির্ভরশীল নয় |
| **O(n)** | `for i in range(n): print(i)` | ইনপুটের সাথে লিনিয়ারলি বৃদ্ধি পায় |

---

### ব্যতিক্রম ক্ষেত্র:
- **বড় সংখ্যার গণিত অপারেশন** (যেমন: ১০০০ ডিজিটের সংখ্যার গুণ) সাধারণত O(1) নয়, কারণ সেগুলো একাধিক স্টেপ নেয়। 
- তবে সাধারণ প্রোগ্রামিং কনটেস্ট বা অ্যালগরিদম অ্যানালাইসিসে সংখ্যাকে ফিক্সড সাইজ ধরা হয়, তাই O(1) হিসেব করা হয়। 

সর্বোপরি, **ইনপুট সাইজের সাথে অপারেশনের সংখ্যা অপরিবর্তিত থাকলে কমপ্লেক্সিটি O(1)** হবে। ✅